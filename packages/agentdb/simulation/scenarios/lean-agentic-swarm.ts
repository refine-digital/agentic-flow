/**
 * Lean-Agentic Swarm Simulation
 *
 * Tests using lean-agentic npm package for lightweight agent orchestration
 */

import { createDatabase } from '../../src/db-fallback.js';
import { ReflexionMemory } from '../../src/controllers/ReflexionMemory.js';
import { SkillLibrary } from '../../src/controllers/SkillLibrary.js';
import { EmbeddingService } from '../../src/controllers/EmbeddingService.js';
import * as path from 'path';

export default {
  description: 'Lean-agentic lightweight swarm with minimal overhead',

  async run(config: Record<string, unknown>) {
    const verbosity = (config.verbosity ?? 2) as number;
    const size = (config.size ?? 3) as number;

    if (verbosity >= 2) {
      console.log(`   âš¡ Initializing Lean-Agentic ${size}-Agent Swarm`);
    }

    // Initialize shared AgentDB
    const embedder = new EmbeddingService({
      model: 'Xenova/all-MiniLM-L6-v2',
      dimension: 384,
      provider: 'transformers'
    });
    await embedder.initialize();

    const db = await createDatabase(
      path.join(process.cwd(), 'simulation', 'data', 'lean-agentic.graph'),
      { embedder, forceMode: 'graph' }
    );

    const results = {
      agents: size,
      operations: 0,
      successfulTasks: 0,
      avgLatency: 0,
      totalTime: 0,
      memoryFootprint: 0
    };

    const startTime = performance.now();

    // Lean agent task - minimal overhead
    const leanAgentTask = async (agentId: number, role: string) => {
      const taskStart = performance.now();

      try {
        if (role === 'memory') {
          // Memory agent: Store and retrieve patterns
          const reflexion = new ReflexionMemory(
            db.getGraphDatabase(),
            embedder,
            undefined,
            undefined,
            db.getGraphDatabase()
          );

          await reflexion.storeEpisode({
            sessionId: `lean-agent-${agentId}`,
            task: `Lightweight task execution ${agentId}`,
            reward: 0.85 + (Math.random() * 0.15),
            success: true,
            input: `Agent ${agentId} input`,
            output: 'Efficient execution'
          });

          const retrieved = await reflexion.retrieveRelevant({
            task: 'task execution',
            k: 3
          });

          results.operations += 2; // store + retrieve

          if (verbosity >= 3) {
            console.log(`      âœ… Memory Agent ${agentId}: Stored 1, Retrieved ${retrieved.length}`);
          }
        } else if (role === 'skill') {
          // Skill agent: Create and search skills
          const skills = new SkillLibrary(
            db.getGraphDatabase(),
            embedder,
            db.getGraphDatabase()
          );

          await skills.createSkill({
            name: `lean-skill-${agentId}`,
            description: `Lightweight skill from agent ${agentId}`,
            code: `function lean${agentId}() { return ${agentId}; }`,
            successRate: 0.9 + (Math.random() * 0.1)
          });

          const found = await skills.searchSkills({
            query: 'lightweight',
            k: 2
          });

          results.operations += 2; // create + search

          if (verbosity >= 3) {
            console.log(`      âœ… Skill Agent ${agentId}: Created 1, Found ${found.length}`);
          }
        } else {
          // Coordinator agent: Query and coordinate
          const reflexion = new ReflexionMemory(
            db.getGraphDatabase(),
            embedder,
            undefined,
            undefined,
            db.getGraphDatabase()
          );

          const episodes = await reflexion.retrieveRelevant({
            task: 'execution',
            k: 5
          });

          results.operations += 1; // query only

          if (verbosity >= 3) {
            console.log(`      âœ… Coordinator Agent ${agentId}: Coordinated ${episodes.length} episodes`);
          }
        }

        const taskEnd = performance.now();
        results.successfulTasks++;

        return {
          agentId,
          role,
          duration: taskEnd - taskStart,
          success: true
        };
      } catch (error) {
        return {
          agentId,
          role,
          duration: performance.now() - taskStart,
          success: false,
          error
        };
      }
    };

    // Execute lean agents with role distribution
    const agentRoles = ['memory', 'skill', 'coordinator'];
    const taskResults = await Promise.all(
      Array.from({ length: size }, (_, i) =>
        leanAgentTask(i, agentRoles[i % agentRoles.length])
      )
    );

    const endTime = performance.now();
    results.totalTime = endTime - startTime;

    // Calculate metrics
    const successfulTasks = taskResults.filter(r => r.success);
    results.avgLatency = successfulTasks.reduce((sum, r) => sum + r.duration, 0) / successfulTasks.length;
    results.memoryFootprint = process.memoryUsage().heapUsed / 1024 / 1024; // MB

    db.close();

    if (verbosity >= 2) {
      console.log(`      ðŸ“Š Agents: ${results.agents}`);
      console.log(`      ðŸ“Š Operations: ${results.operations}`);
      console.log(`      ðŸ“Š Successful Tasks: ${results.successfulTasks}/${size}`);
      console.log(`      ðŸ“Š Avg Agent Latency: ${results.avgLatency.toFixed(2)}ms`);
      console.log(`      ðŸ“Š Memory Footprint: ${results.memoryFootprint.toFixed(2)}MB`);
      console.log(`      â±ï¸  Total Duration: ${results.totalTime.toFixed(2)}ms`);
    }

    if (verbosity >= 3) {
      console.log(`      ðŸ“‹ Agent Results:`, taskResults);
    }

    return results;
  }
};
